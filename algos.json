{"__v":0,"_id":{"$oid":"55201bce021f107d2afa1d8b"},"challenge":"Use Dijkstra's Algorithm to find the shortest distance from u to all the other nodes.","check":"var ans = {y: 4, x: 2, s: 11, u: 0, v: 1}\nreturn _.isEqual(JSON.parse(el.replace(/'/g,'\"')),ans)","module":"Dynamic Programming","name":"Dijkstra's Algorithm","solution":"import sys\nfrom heapq import heappush, heappop\n \nclass Dijkstra:\n    def __init__(self, adjacents):\n        self.adj = adjacents\n        self.n = len(adjacents)\n \n    def dijkstra(self, start):\n        dis, vis, hq = {}, {}, []\n \n        for node in self.adj.keys():\n            # distance, visited\n            dis[node], vis[node] = sys.maxint, False\n \n        dis[start], vis[start] = 0, True\n        heappush(hq, (0, start))\n \n        while hq:\n            (d, node) = heappop(hq)\n            vis[node] = True\n \n            for n, weight in self.adj[node].items():\n                if (not vis[n]) and (d + weight \u003c dis[n]):\n                    dis[n] = d + weight\n                    heappush(hq, (dis[n], n))\n \n        return dis\n \n \ngraph = {\n    's':{'u':10, 'x':5},\n    'u':{'v':1, 'x':2},\n    'v':{'y':4},\n    'x':{'u':3, 'v':9, 'y':2},\n    'y':{'s':7, 'v':6}\n}\n \n \nif __name__ == '__main__':\n    d = Dijkstra(graph)\n    print d.dijkstra('u')","start":"import sys\nfrom heapq import heappush, heappop\n \n\n\ngraph = {\n    's':{'u':10, 'x':5},\n    'u':{'v':1, 'x':2},\n    'v':{'y':4},\n    'x':{'u':3, 'v':9, 'y':2},\n    'y':{'s':7, 'v':6}\n}\n \n \nd = Dijkstra(graph)\nprint d.dijkstra('u')","subject":{"$oid":"551edc0139cc6e7a0f00000b"},"vid":"8Ls1RqHCOPw"}
{"__v":0,"_id":{"$oid":"55242d695e2dfb6b5fc17f26"},"challenge":"Use the Bellman-Ford Algorithm to print the shortest paths from 's' to all other nodes.","check":"var ans = {y: 7, x: 4, s: 0, z: -2, t: 2}\nreturn _.isEqual(JSON.parse(el.replace(/'/g,'\"')),ans)","module":"Dynamic Programming","name":"Bellman-Ford","solution":"graph = { \n    's' : {'t':6, 'y':7},\n    't' : {'x':5, 'z':-4, 'y':8 },\n    'y' : {'z':9, 'x':-3},\n    'z' : {'x':7, 's': 2},\n    'x' : {'t':-2}\n}\n\ndef bellman_ford(graph, s):\n    dist, pred, inf = {}, {}, float('inf')\n    for v in graph:\n        dist[v] = inf\n        pred[v] = None\n    dist[s] = 0\n    edges = [(u, v) for u in graph for v in graph[u].keys()]\n    for i in range(len(graph)-1):\n        for (u, v) in edges:\n            if dist[v] \u003e dist[u] + graph[u][v]:\n                dist[v] = dist[u] + graph[u][v]\n                pred[v] = u\n    for (u, v) in edges:\n        if dist[v] \u003e dist[u] + graph[u][v]:\n            return \"Graph contains a negative cycle\"\n    return dist\n\nprint bellman_ford(graph, 's')","start":"graph = { \n    's' : {'t':6, 'y':7},\n    't' : {'x':5, 'z':-4, 'y':8 },\n    'y' : {'z':9, 'x':-3},\n    'z' : {'x':7, 's': 2},\n    'x' : {'t':-2}\n}\n\n\n\nprint bellman_ford(graph, 's')","subject":{"$oid":"551edc0139cc6e7a0f00000b"},"vid":"iTW2yFYd1Nc"}
{"__v":0,"_id":{"$oid":"55248b8e2ce30aa824592c0d"},"challenge":"Use  the Floyd Warshall Algorithm to find the shortest paths between all pairs of vertices.","check":"ans = [[ 0, -1, -2,  0], [ 4,  0,  2,  4], [ 5,  1,  0,  2], [ 3, -1,  1,  0]]\nel = el.replace(/\\n/g,',')\nel = el.replace(/\\./g,'')\nel = el.replace(/(\\d)\\s/g,\"$1, \")\nel = el.substring(0,el.length-1)\nel = JSON.parse(el)\nreturn _.isEqual(el,ans)","module":"Dynamic Programming","name":"Floyd Warshall","solution":"from numpy import array, inf\n\ndef floyd_warshall(mat):\n    n = len(mat)\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                mat[i,j] = min(mat[i,j], mat[i,k] + mat[k,j])\n    return mat\n\nmatrix = array([\n    [  0.,  inf,  -2.,  inf],\n    [  4.,   0.,   3.,  inf],\n    [ inf,  inf,   0.,   2.],\n    [ inf,  -1.,  inf,   0.]\n])\nprint floyd_warshall(matrix)","start":"from numpy import array, inf\n\n\n\nmatrix = array([\n    [  0.,  inf,  -2.,  inf],\n    [  4.,   0.,   3.,  inf],\n    [ inf,  inf,   0.,   2.],\n    [ inf,  -1.,  inf,   0.]\n])\n\nprint floyd_warshall(matrix)","subject":{"$oid":"551edc0139cc6e7a0f00000b"},"vid":"Qdt5WJVkPbY"}
{"__v":0,"_id":{"$oid":"55258a9069ca6c238a51e81d"},"challenge":"Solve the Knapsack Problem with the given items and weights.","check":"return \"['Hatchet', \\\"Henry David Thoreau's 'Walden'\\\"]\" === el.trim()","module":"Dynamic Programming","name":"Knapsack Problem","solution":"class Item:\n    def __init__(self, name, weight, profit):\n        self.name = name \n        self.weight = weight \n        self.profit = profit\n\ndef knapsack(max, items):\n    knap = [[0]*(max+1) for i in range(len(items)+1)]\n    # iterate through items\n    for idx in range(1,len(items)+1):\n        cur = items[idx-1] # corrects for zero-base\n        # iterate through knapsack weights\n        for knapW in range(1, max+1):\n            if cur.weight \u003e knapW:\n                knap[idx][knapW] = knap[idx-1][knapW]\n            else:\n                inc = knap[idx-1][knapW - cur.weight] + cur.profit\n                if knap[idx-1][knapW] \u003e inc:\n                    knap[idx][knapW] = knap[idx-1][knapW]\n                else:\n                    knap[idx][knapW] = inc\n    stuff = []\n    while idx \u003e 0 and knapW \u003e 0:\n        if knap[idx][knapW] != knap[idx-1][knapW]:    # item was added\n            stuff.append(items[idx-1].name)\n            knapW -= items[idx-1].weight\n        idx-=1\n    stuff.sort()\n    return stuff\n\nitems = [\n    Item(\"Hatchet\", 4, 20),\n    Item(\"Henry David Thoreau's 'Walden'\", 1, 15),\n    Item(\"Laptop\", 5, 6)\n]\nprint knapsack(5, items)","start":"class Item:\n    def __init__(self, name, weight, profit):\n        self.name = name\n        self.weight = weight \n        self.profit = profit\n\n\n\nitems = [\n    Item(\"Hatchet\", 4, 20),\n    Item(\"Henry David Thoreau's 'Walden'\", 1, 15),\n    Item(\"Laptop\", 5, 6)\n]\nprint knapsack(5, items)","subject":{"$oid":"551edc0139cc6e7a0f00000b"},"vid":"EH6h7WA7sDw"}
{"__v":0,"_id":{"$oid":"552b0f22c6e7d632feb9a9df"},"challenge":"Find the longest increasing subsequences.","check":"var seq1 = '[3, 4, 5]'\nvar seq2 = '[0, 4, 6, 9, 13, 15]'\nel = el.trim()\nel= el.split(/\\n/)\nif (el.length !== 2) {\n    return false\n}\nreturn (el[0]===seq1 \u0026\u0026 el[1] === seq2)","module":"Dynamic Programming","name":"Longest Increasing Subsequence","solution":"def lis(d):\n    l = []\n    for i in range(len(d)):\n        l.append(max([l[j] for j in range(i) if l[j][-1] \u003c d[i]] or [[]], key=len) \n                  + [d[i]])\n    return max(l, key=len)\n \nprint lis([3,2,6,4,5,1])\nprint lis([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15])","start":"def lis(d):\n    \n \nprint lis([3,2,6,4,5,1])\nprint lis([0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15])","subject":{"$oid":"551edc0139cc6e7a0f00000b"},"vEnd":null,"vStart":null,"vid":"WFNMFXAjBbA"}
{"__v":0,"_id":{"$oid":"552edf5bbaf43f7cdaedb37d"},"challenge":"Find the items using a binary search algorithm.","check":"var seq1 = '1'\nvar seq2 = 'False'\nel = el.trim()\nel= el.split(/\\n/)\nif (el.length !== 2) {\n    return false\n}\nreturn (el[0]===seq1 \u0026\u0026 el[1] === seq2)","module":"Search","name":"Binary Search","solution":"def search(seq, key):\n    lo = 0\n    hi = len(seq) - 1\n\n    while hi \u003e= lo:\n        mid = lo + (hi - lo) // 2\n        if seq[mid] \u003c key:\n            lo = mid + 1\n        elif seq[mid] \u003e key:\n            hi = mid - 1\n        else:\n            return mid\n    return False\n\nprint search([0, 1, 3, 4, 5], 1)\nprint search([0, 1, 1, 3, 4, 5], 10)","start":"def search(seq, key):\n    \n\nprint search([0, 1, 3, 4, 5], 1)\nprint search([0, 1, 1, 3, 4, 5], 10)","subject":{"$oid":"551edc0139cc6e7a0f00000b"},"vEnd":507,"vStart":270,"vid":"j5uXyPJ0Pew"}
{"__v":0,"_id":{"$oid":"552eef8abaf43f7cdaedb37e"},"challenge":"Use the Boyer Moore Horspool algorithm to find all occurrences of the pattern in the text","check":"return el.trim() === '[0, 5, 7]'","module":"Search","name":"Boyer Moore Horspool","solution":"def bmh(text, pattern):\n    m = len(pattern)\n    n = len(text)\n    offsets = []\n    if m \u003e n:\n        return offsets\n    skip = []\n    for k in range(256):\n        skip.append(m)\n    for k in range(m-1):\n        skip[ord(pattern[k])] = m - k - 1\n    skip = tuple(skip)\n    k = m - 1\n    while k \u003c n:\n        j = m - 1; i = k\n        while j \u003e= 0 and text[i] == pattern[j]:\n            j -= 1\n            i -= 1\n        if j == -1:\n            offsets.append(i + 1)\n        k += skip[ord(text[k])]\n\n    return offsets\n\nprint bmh('ababbababa', 'aba')","start":"def bmh(text, pattern):\n    \n\nprint bmh('ababbababa', 'aba')","subject":{"$oid":"551edc0139cc6e7a0f00000b"},"vEnd":331,"vStart":143,"vid":"PHXAOKQk2dw"}
{"__v":0,"_id":{"$oid":"55345bb39416a61d0eb61c7e"},"challenge":"Use the Depth First Search Algorithm to explore each node before backtracking.","check":"return el.trim() === \"set(['A', 'C', 'B', 'E', 'D', 'F'])\"","module":"Search","name":"Depth First Search","solution":"graph = {\n    'A': set(['B', 'C']),\n    'B': set(['A', 'D', 'E']),\n    'C': set(['A', 'F']),\n    'D': set(['B']),\n    'E': set(['B', 'F']),\n    'F': set(['C', 'E'])\n}\n\ndef dfs(graph, start):\n    vis, stack = set(), [start]\n    while stack:\n        vtx = stack.pop()\n        if vtx not in vis:\n            vis.add(vtx)\n            stack.extend(graph[vtx] - vis)\n    return vis\n\nprint dfs(graph, 'A')","start":"graph = {\n    'A': set(['B', 'C']),\n    'B': set(['A', 'D', 'E']),\n    'C': set(['A', 'F']),\n    'D': set(['B']),\n    'E': set(['B', 'F']),\n    'F': set(['C', 'E'])\n}\n\ndef dfs(graph, start):\n    \n\nprint dfs(graph, 'A')","subject":{"$oid":"551edc0139cc6e7a0f00000b"},"vEnd":267,"vid":"zLZhSSXAwxI"}
{"__v":0,"_id":{"$oid":"55347a9f9416a61d0eb61c80"},"challenge":"Use the Breadth First Search algorithm to explore the neighbor nodes first before moving on to the next level nodes.","check":"return el.trim() === \"set(['A', 'C', 'B', 'E', 'D', 'F'])\"","module":"Search","name":"Breadth First Search","solution":"graph = {\n    'A': set(['B', 'C']),\n    'B': set(['A', 'D', 'E']),\n    'C': set(['A', 'F']),\n    'D': set(['B']),\n    'E': set(['B', 'F']),\n    'F': set(['C', 'E'])\n}\n\ndef bfs(graph, start):\n    vis, q = set(), [start]\n    while q:\n        vtx = q.pop(0)\n        if vtx not in vis:\n            vis.add(vtx)\n            q.extend(graph[vtx] - vis)\n    return vis\n\nprint bfs(graph, 'A')","start":"graph = {\n    'A': set(['B', 'C']),\n    'B': set(['A', 'D', 'E']),\n    'C': set(['A', 'F']),\n    'D': set(['B']),\n    'E': set(['B', 'F']),\n    'F': set(['C', 'E'])\n}\n\ndef bfs(graph, start):\n    \n\nprint bfs(graph, 'A')","subject":{"$oid":"551edc0139cc6e7a0f00000b"},"vStart":267,"vid":"zLZhSSXAwxI"}
{"__v":0,"_id":{"$oid":"553488299416a61d0eb61c82"},"challenge":"Use the Knuth-Morris-Pratt algorithm to find the index of the pattern","check":"return el.trim() === \"[3, 6, 9, 11, 13, 19, 21, 23]\"","module":"Search","name":"Knuth-Morris-Pratt Algorithm","solution":"def kmp(t, p):\n    p = list(p)\n    shifts = [1] * (len(p) + 1)\n    shift = 1\n    for pos in range(len(p)):\n        while shift \u003c= pos and p[pos] != p[pos-shift]:\n            shift += shifts[pos-shift]\n        shifts[pos+1] = shift\n    startPos = 0\n    matchLen = 0\n    for c in t:\n        while matchLen == len(p) or \\\n        matchLen \u003e= 0 and p[matchLen] != c:\n            startPos += shifts[matchLen]\n            matchLen -= shifts[matchLen]\n        matchLen += 1\n        if matchLen == len(p):\n            yield startPos\n\nprint [i for i in kmp('aabbabbabbababaaabbbababa','ba')]","start":"def kmp(t, p):\n    \n\nprint [i for i in kmp('aabbabbabbababaaabbbababa','ba')]","subject":{"$oid":"551edc0139cc6e7a0f00000b"},"vEnd":432,"vStart":91,"vid":"HaAu5ZGj6fc"}
